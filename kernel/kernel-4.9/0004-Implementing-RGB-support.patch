From 7c1f8f8ce0965d4226f8fcf4197f3b75bb07c0b3 Mon Sep 17 00:00:00 2001
From: Alex Gantman <alexander.gantman@intel.com>
Date: Tue, 29 Oct 2019 20:13:59 +0200
Subject: [PATCH] d4xx: Implementing RGB support

Signed-off-by: Alex Gantman <alexander.gantman@intel.com>
---
 drivers/media/i2c/d4xx/Makefile            |   6 ++
 drivers/media/i2c/d4xx/d4xx_rgbflv_rs.c    |   2 +
 drivers/media/i2c/d4xx/d4xx_rs.c           | 128 ++++++++++++-----------------
 drivers/media/i2c/d4xx/rs_d4xx.h           |   9 +-
 drivers/media/i2c/d4xx/rs_d4xx_mode_tbls.h | 112 ++++++++++++++++---------
 5 files changed, 140 insertions(+), 117 deletions(-)
 create mode 100644 drivers/media/i2c/d4xx/d4xx_rgbflv_rs.c

diff --git a/drivers/media/i2c/d4xx/Makefile b/drivers/media/i2c/d4xx/Makefile
index aec3197..83daaa2 100644
--- a/drivers/media/i2c/d4xx/Makefile
+++ b/drivers/media/i2c/d4xx/Makefile
@@ -1,5 +1,11 @@
 ccflags-y += -Idrivers/media/i2c
+
 d4xx-objs    := d4xx_rs.o d4xx_dfu.o
 obj-$(CONFIG_VIDEO_RSD4XX) += d4xx.o
+
+d4xx_rgbflv-objs    := d4xx_rgbflv_rs.o d4xx_dfu.o
+CFLAGS_d4xx_rgbflv_rs.o += -D_RGB_FLAYVOR
+obj-$(CONFIG_VIDEO_RSD4XX) += d4xx_rgbflv.o
+
  
 
diff --git a/drivers/media/i2c/d4xx/d4xx_rgbflv_rs.c b/drivers/media/i2c/d4xx/d4xx_rgbflv_rs.c
new file mode 100644
index 0000000..79111de
--- /dev/null
+++ b/drivers/media/i2c/d4xx/d4xx_rgbflv_rs.c
@@ -0,0 +1,2 @@
+/* Generic kernel solution ref: arch/x86/boot/video-vesa.c */
+#include "d4xx_rs.c"
diff --git a/drivers/media/i2c/d4xx/d4xx_rs.c b/drivers/media/i2c/d4xx/d4xx_rs.c
index 6311c95..0205864 100644
--- a/drivers/media/i2c/d4xx/d4xx_rs.c
+++ b/drivers/media/i2c/d4xx/d4xx_rs.c
@@ -45,7 +45,11 @@
 #include "rs_d4xx_mode_tbls.h"
 
 static const struct of_device_id d4xx_of_match[] = {
+#ifdef _RGB_FLAYVOR
+	{ .compatible = "intel,d4xx_rgbflv",},
+#else
 	{ .compatible = "intel,d4xx",},
+#endif
 	{ },
 };
 MODULE_DEVICE_TABLE(of, d4xx_of_match);
@@ -231,24 +235,20 @@ static int d4xx_hw_set_auto_exposure(struct d4xx *state, u32 val)
 {
 	int ret;
 	u16 value;
-	if (state->is_rgb) {
-		if (0 == val)
-			val = 1;
-		else
-			val = 8;
-		d4xx_read(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
-		ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, val);
-		d4xx_read(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
-		d4xx_read(state, 0x401C, &value);
-		d4xx_read(state, 0x403C, &value);
-	}
-	else {
-		d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
-		ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, val);
-		d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
-		d4xx_read(state, 0x401C, &value);
-		d4xx_read(state, 0x403C, &value);
-	}
+#ifdef _RGB_FLAYVOR 
+	val = (val ? 8 : 1);
+	d4xx_read(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
+	ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, val);
+	d4xx_read(state, D4XX_RGB_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
+	d4xx_read(state, 0x401C, &value);
+	d4xx_read(state, 0x403C, &value);
+#else
+	d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
+	ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, val);
+	d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_AUTO_EXPOSURE_MODE, &value);
+	d4xx_read(state, 0x401C, &value);
+	d4xx_read(state, 0x403C, &value);
+#endif
 	return ret;
 }
 
@@ -258,35 +258,25 @@ static int d4xx_hw_set_exposure(struct d4xx *state, u32 val)
 	int ret;
 	u16 value;
 
-	if (!state->is_rgb) {
-		if (val < 10)
-			val = 1000;
-		else if (val > 1660)
-			val = 166000;
-		else
-			val *= 100;
-	} else {
-		if (val < 1)
-			val = 1;
-		else if (val > 10000)
-			val = 10000;
-	}
-
-	if (state->is_rgb) {
-		//if (state->rgb.sensor.streaming)
-			ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_MSB, val >> 16);
-	}
+#ifdef _RGB_FLAYVOR 
+	if (val < 10)
+		val = 1000;
+	else if (val > 1660)
+		val = 166000;
 	else
-		ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_MSB, val >> 16);
-
-	if (!ret) {
-		if (state->is_rgb) {
-			//if (state->rgb.sensor.streaming)
-				ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_LSB, val & 0xffff);
-		}
-		else
-			ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_LSB, val & 0xffff);
-	}
+		val *= 100;
+	ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_MSB, val >> 16);
+	if (!ret) 
+		ret = d4xx_write(state, D4XX_RGB_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_LSB, val & 0xffff);
+#else
+	if (val < 1)
+		val = 1;
+	else if (val > 10000)
+		val = 10000;
+	ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_MSB, val >> 16);
+	if (!ret) 
+		ret = d4xx_write(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_LSB, val & 0xffff);
+#endif
 
 	d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_LSB, &value);
 	d4xx_read(state, D4XX_DEPTH_CONTROL_BASE | D4XX_MANUAL_EXPOSURE_MSB, &value);
@@ -592,7 +582,6 @@ static int d4xx_parse_cam(struct i2c_client *client, struct d4xx *state)
 
 static int d4xx_hw_init(struct i2c_client *c, struct d4xx *state)
 {
-	struct v4l2_subdev *sd = &state->mux.sd.subdev;
 	u16 mipi_status = 0, n_lanes = 0, phy = 0, drate_min = 0, drate_max = 0;
 	int ret = d4xx_read(state, 0x300, &n_lanes);
 	if (!ret)
@@ -605,7 +594,7 @@ static int d4xx_hw_init(struct i2c_client *c, struct d4xx *state)
 		ret = d4xx_read(state, 0x30a, &drate_max);
 
 	if (!ret)
-		dev_info(sd->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
+		dev_info(&c->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
 			 __func__, __LINE__, n_lanes, phy, drate_min, drate_max);
 
 #ifdef CONFIG_TEGRA_CAMERA_PLATFORM
@@ -622,7 +611,7 @@ static int d4xx_hw_init(struct i2c_client *c, struct d4xx *state)
 	if (!ret)
 		ret = d4xx_read(state, 0x500, &mipi_status);
 
-	dev_info(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
+	dev_info(&c->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
 		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
 
 	return ret;
@@ -670,16 +659,8 @@ static int d4xx_ctrl_init(struct d4xx *state)
 {
 	const struct v4l2_ctrl_ops *ops = &d4xx_ctrl_ops;
 	struct d4xx_ctrls *ctrls = &state->ctrls;
-	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
-	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct v4l2_ctrl_handler *hdl = &state->s_data->tegracam_ctrl_hdl->ctrl_handler;
 	u8 max;
-	int ret;
-
-	ret = v4l2_ctrl_handler_init(hdl, D4XX_N_CONTROLS);
-	if (ret < 0) {
-		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
-		return ret;
-	}
 
 	ctrls->log = v4l2_ctrl_new_custom(hdl, &d4xx_ctrl_log, NULL);
 
@@ -710,13 +691,6 @@ static int d4xx_ctrl_init(struct d4xx *state)
 	// TODO: this prevents setting of manual exposure
 	// v4l2_ctrl_auto_cluster(3, &ctrls->auto_exp, 0, false);
 
-	if (hdl->error) {
-		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
-		ret = hdl->error;
-		v4l2_ctrl_handler_free(hdl);
-		return ret;
-	}
-
 	// TODO: consider invoking v4l2_ctrl_handler_setup(hdl);
 
 	state->mux.sd.subdev.ctrl_handler = hdl;
@@ -954,7 +928,19 @@ static int d4xx_set_mode(struct tegracam_device *tc_dev)
 		dev_err(dev, "Failed to write table id\n");
 		return err;
 	}
-
+#ifdef _RGB_FLAYVOR
+	err = d4xx_read(priv, D4XX_RGB_STREAM_DT, &cfg0);
+	if (!err)
+		err = d4xx_read(priv, D4XX_RGB_STREAM_MD, &cfg1);
+	if (!err)
+		err = d4xx_read(priv, D4XX_RGB_RES_WIDTH, &dw);
+	if (!err)
+		err = d4xx_read(priv, D4XX_RGB_RES_HEIGHT, &dh);
+	if (!err)
+		err = d4xx_read(priv, D4XX_RGB_RES_WIDTH, &yw);
+	if (!err)
+		err = d4xx_read(priv, D4XX_RGB_RES_HEIGHT, &yh);
+#else
 	err = d4xx_read(priv, D4XX_DEPTH_Y_STREAMS_DT, &cfg0);
 	if (!err)
 		err = d4xx_read(priv, D4XX_DEPTH_Y_STREAMS_MD, &cfg1);
@@ -966,6 +952,7 @@ static int d4xx_set_mode(struct tegracam_device *tc_dev)
 		err = d4xx_read(priv, D4XX_Y_RES_WIDTH, &yw);
 	if (!err)
 		err = d4xx_read(priv, D4XX_Y_RES_HEIGHT, &yh);
+#endif
 	if (!err)
 		err = d4xx_read(priv, D4XX_DEVICE_TYPE, &dev_type);
 	if (err < 0)
@@ -1128,7 +1115,7 @@ static int d4xx_probe(struct i2c_client *c, const struct i2c_device_id *id)
 	state->tc_dev->client = c;
 	state->tc_dev->dev = &c->dev;
 
-	strncpy(state->tc_dev->name, "d4xx", sizeof(state->tc_dev->name));
+	strncpy(state->tc_dev->name, D4XX_DRIVER_NAME, sizeof(state->tc_dev->name));
 
 	state->tc_dev->dev_regmap_config = &d4xx_regmap_config;
 	state->tc_dev->sensor_ops = &d4xx_common_ops;
@@ -1161,13 +1148,6 @@ static int d4xx_probe(struct i2c_client *c, const struct i2c_device_id *id)
 
 	err = of_property_read_string(c->dev.of_node, "cam-type",
 			&str);
-	if (!err && !strncmp(str, "RGB", strlen("RGB"))) {
-		mode_table = mode_table_rgb;
-		state->is_rgb = 1;
-	} else
-		mode_table = mode_table_depth;
-	
-
 	ret = d4xx_v4l_init(state->tc_dev);
 	if (ret < 0)
 		goto e_regulator;
diff --git a/drivers/media/i2c/d4xx/rs_d4xx.h b/drivers/media/i2c/d4xx/rs_d4xx.h
index c55da72..8d287e2 100644
--- a/drivers/media/i2c/d4xx/rs_d4xx.h
+++ b/drivers/media/i2c/d4xx/rs_d4xx.h
@@ -24,10 +24,16 @@
 
 
 //#define D4XX_DRIVER_NAME "DS5 RealSense camera driver"
+#ifdef _RGB_FLAYVOR
+#define D4XX_DRIVER_NAME "d4xx_rgbflv"
+#define D4XX_DRIVER_NAME_CLASS "d4xx_rgbflv-class"
+#else
 #define D4XX_DRIVER_NAME "d4xx"
+#define D4XX_DRIVER_NAME_CLASS "d4xx-class"
+#endif
+
 #define D4XX_DRIVER_NAME_AWG "d4xx-awg"
 #define D4XX_DRIVER_NAME_ASR "d4xx-asr"
-#define D4XX_DRIVER_NAME_CLASS "d4xx-class"
 #define D4XX_DRIVER_NAME_DFU "d4xx-dfu"
 #define D4XX_START_POLL_TIME	10
 #define D4XX_START_MAX_TIME	50
@@ -65,7 +71,6 @@ struct d4xx {
 	struct regulator *vcc;
 	struct tegracam_device *tc_dev;
 	struct camera_common_data *s_data;
-	int is_rgb;
 	u16 fw_version;
 	u16 fw_build;
 };
diff --git a/drivers/media/i2c/d4xx/rs_d4xx_mode_tbls.h b/drivers/media/i2c/d4xx/rs_d4xx_mode_tbls.h
index 8ac2e24..4732db9 100644
--- a/drivers/media/i2c/d4xx/rs_d4xx_mode_tbls.h
+++ b/drivers/media/i2c/d4xx/rs_d4xx_mode_tbls.h
@@ -65,12 +65,29 @@
 
 #define d4xx_reg struct reg_8
 
+#ifdef _RGB_FLAYVOR
+static d4xx_reg d4xx_start[] = {
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START},
+	{0x1000, 0x000},
+	{0x1001, 0x02},
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START*5},
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START},
+	{D4XX_TABLE_END, 0x00}
+};
 
+static d4xx_reg d4xx_stop[] = {
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_STOP},
+	{0x1000, 0x00},
+	{0x1001, 0x01},
+	{D4XX_TABLE_END, 0x00}
+};
+
+#else
 static d4xx_reg d4xx_start[] = {
-	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START}, 
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START},
 	{0x1000, 0x02},
-	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START*5}, 
-	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START}, 
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START*5},
+	{D4XX_TABLE_WAIT_MS, D4XX_WAIT_MS_START},
 	{D4XX_TABLE_END, 0x00}
 };
 
@@ -79,7 +96,34 @@ static d4xx_reg d4xx_stop[] = {
 	{0x1000, 0x01},
 	{D4XX_TABLE_END, 0x00}
 };
+#endif
+
 
+#ifdef _RGB_FLAYVOR
+/* RGB section */
+static  d4xx_reg d465_1920x1080_rgb[] = {
+	{D4XX_RGB_STREAM_DT, 0x1e},
+	{D4XX_RGB_STREAM_MD, 0x00},
+	{D4XX_RGB_FPS, 0x1e},
+	{D4XX_RGB_RES_WIDTH, 0x80},
+	{D4XX_RGB_RES_WIDTH_HI, 0x07},
+	{D4XX_RGB_RES_HEIGHT, 0x38},
+	{D4XX_RGB_RES_HEIGHT_HI, 0x04},
+	{D4XX_TABLE_END, 0x00}
+};
+
+static  d4xx_reg d465_1280x720_rgb[] = {
+	{D4XX_RGB_STREAM_DT, 0x1e},
+	{D4XX_RGB_STREAM_MD, 0x00},
+	{D4XX_RGB_FPS, 0x1e},
+	{D4XX_RGB_RES_WIDTH, 0x00},
+	{D4XX_RGB_RES_WIDTH_HI, 0x05},
+	{D4XX_RGB_RES_HEIGHT, 0xd0 },
+	{D4XX_RGB_RES_HEIGHT_HI, 0x02},
+	{D4XX_TABLE_END, 0x00}
+};
+#else
+/*Depth section */
 static  d4xx_reg d465_1280x960_z16[] = {
 	{D4XX_DEPTH_Y_STREAMS_DT, 0x31},
 	{D4XX_DEPTH_Y_STREAMS_MD, 0x00},
@@ -123,36 +167,18 @@ static  d4xx_reg d465_320x240_z16[] = {
 	{D4XX_DEPTH_RES_HEIGHT_HI, 0x00},
 	{D4XX_TABLE_END, 0x00}
 };
+#endif
 
-static  d4xx_reg d465_1920x1080_rgb[] = {
-	{D4XX_RGB_STREAM_DT, 0x1e},
-	{D4XX_RGB_STREAM_MD, 0x00},
-	{D4XX_RGB_FPS, 0x1e},
-	{D4XX_RGB_RES_WIDTH, 0x80},
-	{D4XX_RGB_RES_WIDTH_HI, 0x07},
-	{D4XX_RGB_RES_HEIGHT, 0x38},
-	{D4XX_RGB_RES_HEIGHT_HI, 0x04},
-	{D4XX_TABLE_END, 0x00}
-};
-
-static  d4xx_reg d465_1280x720_rgb[] = {
-	{D4XX_RGB_STREAM_DT, 0x1e},
-	{D4XX_RGB_STREAM_MD, 0x00},
-	{D4XX_RGB_FPS, 0x1e},
-	{D4XX_RGB_RES_WIDTH, 0x00},
-	{D4XX_RGB_RES_WIDTH_HI, 0x05},
-	{D4XX_RGB_RES_HEIGHT, 0xd0 },
-	{D4XX_RGB_RES_HEIGHT_HI, 0x02},
-	{D4XX_TABLE_END, 0x00}
-};
-
-enum {
+enum d4xx_depth_modes {
+#ifdef _RGB_FLAYVOR
+	D465_MODE_1920X1080_RGB,
+	D465_MODE_1280X720_RGB,
+#else
 	D465_MODE_1280X960_Z16,
 	D465_MODE_960X720_Z16,
 	D465_MODE_640X480_Z16,
 	D465_MODE_320X240_Z16,
-	D465_MODE_1920X1080_RGB,
-	D465_MODE_1280X720_RGB,
+#endif
 	D4XX_MODE_START_STREAM,
 	D4XX_MODE_STOP_STREAM,
 };
@@ -170,31 +196,33 @@ static const int D4XX_6_30fps[] = {
 	30,
 };
 
-typedef d4xx_reg *mode_table_arr[];
-
-
-static mode_table_arr mode_table_depth = {
+static d4xx_reg *mode_table[] = {
+#ifdef _RGB_FLAYVOR
+	[D465_MODE_1920X1080_RGB] = d465_1920x1080_rgb,
+	[D465_MODE_1280X720_RGB] = d465_1280x720_rgb,
+#else
 	[D465_MODE_1280X960_Z16]	= d465_1280x960_z16,
 	[D465_MODE_960X720_Z16]		= d465_960x720_z16,
 	[D465_MODE_640X480_Z16]		= d465_640x480_z16,
 	[D465_MODE_320X240_Z16]		= d465_320x240_z16,
+#endif
 	[D4XX_MODE_START_STREAM]	= d4xx_start,
 	[D4XX_MODE_STOP_STREAM]		= d4xx_stop,
 };
 
-static mode_table_arr mode_table_rgb = {
-	[D465_MODE_1920X1080_RGB] = d465_1920x1080_rgb,
-	[D465_MODE_1280X720_RGB] = d465_1280x720_rgb,
-	[D4XX_MODE_START_STREAM] = d4xx_start,
-	[D4XX_MODE_STOP_STREAM] = d4xx_stop,
-};
-
-static d4xx_reg **mode_table = NULL;
-
 /*
  * WARNING: frmfmt ordering need to match mode definition in
  * device tree!
  */
+#ifdef _RGB_FLAYVOR
+static const struct camera_common_frmfmt d4xx_frmfmt[] = {
+	{{1920, 1080}, D4XX_6_30fps, 2, 1,
+			D465_MODE_1920X1080_RGB},
+	{{1280, 720}, D4XX_6_30fps, 2, 1,
+			D465_MODE_1280X720_RGB},
+	/* Add modes with no device tree support after below */
+};
+#else
 static const struct camera_common_frmfmt d4xx_frmfmt[] = {
 	{{1280, 960}, D4XX_6_30fps, 2, 1,
 			D465_MODE_1280X960_Z16},
@@ -206,4 +234,6 @@ static const struct camera_common_frmfmt d4xx_frmfmt[] = {
 			D465_MODE_320X240_Z16},
 	/* Add modes with no device tree support after below */
 };
+#endif
+
 #endif /* __D4XX_I2C_TABLES__ */
-- 
2.7.4

